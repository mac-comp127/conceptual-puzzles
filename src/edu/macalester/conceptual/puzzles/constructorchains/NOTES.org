* notes for puzzles on constructor chains

Idea here is to have some inheritance hierarchy with various
constructors, and to test students' understanding of how the various
super() constructors get called.

Copy over my examples. For difficulties:

(The end question is always "what gets printed?" from the constructors.)

Minimum difficulty for credit: 3.

1. Linear hierarchy at least 3 levels deep. Just default constructors, each
   just prints something class-specific. Call new for the leaf class, or
   perhaps something in the middle.
2. Like 1, but with one or more classes in the chain having a
   non-default constructor, and a parent with a non-default constructor
   of the same signature. Child non-default calls the parent
   non-default. Call new in a way that may (or may not!) go through the
   non-defaults.
3. Like 2, but mix up default and non-default: have a default call a
   non-default and vice versa. Call new in a way that does/does not go
   through default constructor.
4. Like 3, but two leaf classes. Problem asks for output for the
   creation of one of each of those leaf classes from some external
   context.
5. Non-linear topology, with same kind of constructor calls as in 4.
   Sibling classes not necessarily as leaves. But now one of the
   constructors for class A creates an instance of class B (which could
   be some ancestor or descendant...). Question involves creating an A
   or subclass thereof.
6. Like 5, but more classes -- either at top or bottom of chain, or more
   siblings.
7. Like 6, but now multiple levels with siblings. Problem may involve
   creating two instances: one goes through just one of the "sibling
   levels", the other goes through both.
8. Like 7 but either "taller" or "wider".
9. Like 8 but again, either taller or wider.

** sample code

#+begin_src java
class Organism {
    public Organism() {
        System.out.println("Organism default ctor");
    }

    public Organism(int n) {
        System.out.println("Organism one-int ctor n=" + n);
    }
}

class Animal extends Organism {
    public Animal() {
        super(); // want examples that do and do not explicitly call parent ctor
        System.out.println("animal default ctor");
    }

    public Animal(int m) {
        super(m + 1); // want examples of calling non-default ctor
        System.out.println("animal int ctor m=" + m);
    }

    public Animal(String s) {
        System.out.println("animal string ctor s=" + s);
    }
}

class Plant extends Organism { // want multiple children of some class
    public Plant() {
        super(2);
        System.out.println("plant def ctor");
    }

    public Plant(String type) {
        System.out.println("instantiating a '" + type + "' plant.");
    }
}

class Herbivore extends Animal() {

    private Plant favoriteFood;

    public Herbivore() {
        favoriteFood = new Plant();
    }
}
#+end_src
* Danny Kluver's inheritance problem
:PROPERTIES:
:CREATED:  [2025-10-11T16:05:14-0500]
:END:

See email from Paul Oct 9, 2025, 9:00 PM:

#+begin_src java
public class Apple {
    protected int dog;
    public Apple(int doggie) {
        dog = doggie;
    }
    public void earth() {
        dog = dog + 1;
    }
    public int flop(int harp) {
        for (int i = 0; i<harp; i++) {
            earth();
        }
        System.out.println(this);
        return dog;
    }
    public String toString() {
        return "Apple dog="+dog;
    }
}

public class Banana extends Apple {
    private int cat;
    public Banana(int garf) {
        super(0);
        cat = garf;
    }
    public void earth() {
        dog = dog + cat;
    }
    public String toString() {
        String retval = "Banana";
        retval = retval + " dog="+dog;
        retval = retval + " cat="+cat;
        return retval;
    }
}

public class FruitSalad {
    public static void main(String[] args) {
        Apple jack = new Apple(18);
        Apple karp = new Banana(3);
        Banana nanna = new Banana(5);

        jack.earth();
        karp.earth();
        nanna.earth();

        System.out.println(jack);
        System.out.println(karp);
        System.out.println(nanna);

        jack.flop(3);
        karp.flop(4);
        nanna.flop(5);
    }
}
#+end_src

Question: What would be printed if we were to run the main method on
FruitSalad?
** parameters affecting difficulty?
- inheritance hierarchy topology -- depth of chain, or complexity
  overall if siblings;
- number of fields in the classes
- variety of access modifiers in the classes
- variety of static and nonstatic
- number of methods using the fields
- whether the methods print or not
- whether the methods mutate fields or not
- whether the constructors print or not
- whether any methods are overridden or not
- calls to this.method or super.method that do or do not invoke the most
  obvious-seeming method -- i.e., you call this.method while
  syntactically in class A, but the code executed at runtime is in class
  B because of overrides or inheritance.

* unrelated: use Shipping Forecast-related places instead of nonsense words
:PROPERTIES:
:CREATED:  [2025-10-11T15:46:30-0500]
:END:

https://en.wikipedia.org/wiki/Inshore_coastal_areas_of_the_United_Kingdom#See_also

https://en.wikipedia.org/wiki/List_of_coastal_weather_stations_in_the_British_Isles

someone wrote a linguistics paper analyzing the structure of the
shipping forecast; it seems to pretty much describe an algorithm one
could use to generate realistic but fake shipping forecasts:
https://www.researchgate.net/profile/Ana-Bocanegra-Valle/publication/286541475_The_Constructing_of_Shipping_Forecasts_in_English_A_Pilot_Study/links/566d64c708ae430ab4ffe8a1/The-Constructing-of-Shipping-Forecasts-in-English-A-Pilot-Study.pdf?origin=publication_detail&_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uRG93bmxvYWQiLCJwcmV2aW91c1BhZ2UiOiJwdWJsaWNhdGlvbiJ9fQ

* "test drive" problem given to ambitious volunteer students
Here's what I sent to Cory Li and Rigo Tesoro:

With the following class declarations:
#+begin_src java
    public class Lochy {
        public Lochy() {
        }
    }

    public class GreatOrmeHead extends Lochy {
        public GreatOrmeHead() {
            Lochy myLochy = new Lochy();
            System.out.println("GreatOrmeHead default constructor");
        }
    }

    public class Humber extends GreatOrmeHead {
        public Humber() {
            Lochy myLochy = new Lochy();
        }
    }

    public class Shannon extends Humber {
        public Shannon() {
            Humber myHumber = new Humber();
            System.out.println("Shannon default constructor");
        }
    }
#+end_src

What gets printed when you create an instance of Shannon?

Solution:

#+begin_quote
GreatOrmeHead default constructor
GreatOrmeHead default constructor
Shannon default constructor
#+end_quote

Also asked "In addition to working through the puzzle below, I'd also
like feedback on what you think about it. How hard did you think it was?
Does it seem like too much? How much did you struggle? Was it too
confusing? Do you see how it is related to things we have studied in
this class?"

** Rigo's comments
I didn't think it was very hard for me, but it was a clever trick that I
think is very much worth having a problem about. I wouldn't be surprised
if some other people in the class would find it more difficult than I
did, but it's not necessarily the hardest puzzle I've seen.

It seems like about the perfect amount for this kind of problem, really.
If there were any more classes the actual thing the problem's checking
for would get a bit swamped in the subclass soup, and if there were any
fewer classes there would be no good opportunity to check for the thing
at all.

I didn't really struggle with it at all, but it still took me
multiple passes through the code to actually notice the trick. (I almost
thought I had already finished the problem before I saw it, which I
think is perfect for this kind of puzzle.) It seems likely to me that a
lot of people would submit an answer with only one GreatOrmeHead default
constructor fairly readily and then get stuck when they see that it's
wrong. Not that I think that's at all a bad thing.

It's definitely not too confusing for me. It might be pretty confusing
for people who spend long enough before noticing the trick with the
problem, but I think that would be to the extent to which is appropriate
for a problem like this anyway, so I wouldn't call that too confusing.

I think it's the right amount of confusing. I can definitely see how
it's related to things we've learned in the class. It's talking about
the whole thing where constructors automatically call super();
immediately if you don't do that yourself.

All in all, I think this is a great problem. It's exactly as concise as
it needs to be, and it's the right difficulty to catch you unawares if
you aren't paying attention but neither be tedious nor be baffling
instead. It has one main trick and exactly one other thing going onâ€”one
more thing and it would be too complicated, one less and it would be too
easy. I really like it!
