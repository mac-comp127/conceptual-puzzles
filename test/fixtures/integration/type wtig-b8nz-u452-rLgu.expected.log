Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8
[0J────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public interface OalRinstar {

        public OalRinstar outo(OalRinstar ofui);
    }

    public class Detpha implements OalRinstar {
        public OalRinstar outo(OalRinstar ofui) {
            return this;
        }
    }

    public class NacCisa implements OalRinstar {
        public OalRinstar outo(OalRinstar ofui) {
            return ofui;
        }
    }

...and given the following setup code:

    NacCisa foo = new NacCisa();
    OalRinstar bar = new Detpha();

[1m[38;5;16m[48;5;207m            [0m
[1m[38;5;16m[48;5;207m   PART 1   [0m
[1m[38;5;16m[48;5;207m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.outo(bar.outo(bar))

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;213m[48;5;53m              [0m
[1m[38;5;213m[48;5;53m   SOLUTION   [0m
[1m[38;5;213m[48;5;53m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;227m            [0m
[1m[38;5;16m[48;5;227m   PART 2   [0m
[1m[38;5;16m[48;5;227m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;228m[48;5;58m              [0m
[1m[38;5;228m[48;5;58m   SOLUTION   [0m
[1m[38;5;228m[48;5;58m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public interface HuCasmad {

        public HuCasmad mairbu(HuCasmad is);
    }

    public class VedEte implements HuCasmad {
        public HuCasmad mairbu(HuCasmad is) {
            return this;
        }
    }

    public class AcirCiccon implements HuCasmad {
        public HuCasmad mairbu(HuCasmad is) {
            return this;
        }
    }

...and given the following setup code:

    HuCasmad foo = new AcirCiccon();
    VedEte bar = new VedEte();

[1m[38;5;16m[48;5;75m            [0m
[1m[38;5;16m[48;5;75m   PART 1   [0m
[1m[38;5;16m[48;5;75m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.mairbu(bar).mairbu(bar)

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;117m[48;5;17m              [0m
[1m[38;5;117m[48;5;17m   SOLUTION   [0m
[1m[38;5;117m[48;5;17m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;204m            [0m
[1m[38;5;16m[48;5;204m   PART 2   [0m
[1m[38;5;16m[48;5;204m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;211m[48;5;52m              [0m
[1m[38;5;211m[48;5;52m   SOLUTION   [0m
[1m[38;5;211m[48;5;52m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public interface Iderl {

        public Iderl fiocio(Iderl wic);
    }

    public class Prerros implements Iderl {
        public Iderl fiocio(Iderl wic) {
            return this;
        }
    }

    public class Splound implements Iderl {
        public Iderl fiocio(Iderl wic) {
            return this;
        }
    }

...and given the following setup code:

    Iderl foo = new Splound();
    Iderl bar = new Prerros();

[1m[38;5;16m[48;5;83m            [0m
[1m[38;5;16m[48;5;83m   PART 1   [0m
[1m[38;5;16m[48;5;83m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.fiocio(foo).fiocio(bar)

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;120m[48;5;22m              [0m
[1m[38;5;120m[48;5;22m   SOLUTION   [0m
[1m[38;5;120m[48;5;22m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;99m            [0m
[1m[38;5;16m[48;5;99m   PART 2   [0m
[1m[38;5;16m[48;5;99m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;141m[48;5;17m              [0m
[1m[38;5;141m[48;5;17m   SOLUTION   [0m
[1m[38;5;141m[48;5;17m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public interface Ulcur {

        public Ulcur desmis(Ulcur dosm);
    }

    public class Preupsdo implements Ulcur {
        public Ulcur desmis(Ulcur dosm) {
            return dosm;
        }
    }

    public class Mecun implements Ulcur {
        public Ulcur desmis(Ulcur dosm) {
            return dosm;
        }
    }

...and given the following setup code:

    Mecun foo = new Mecun();
    Preupsdo bar = new Preupsdo();

[1m[38;5;16m[48;5;221m            [0m
[1m[38;5;16m[48;5;221m   PART 1   [0m
[1m[38;5;16m[48;5;221m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.desmis(bar.desmis(bar))

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;222m[48;5;52m              [0m
[1m[38;5;222m[48;5;52m   SOLUTION   [0m
[1m[38;5;222m[48;5;52m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;87m            [0m
[1m[38;5;16m[48;5;87m   PART 2   [0m
[1m[38;5;16m[48;5;87m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;123m[48;5;23m              [0m
[1m[38;5;123m[48;5;23m   SOLUTION   [0m
[1m[38;5;123m[48;5;23m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public class Iprorn {
        public Iprorn sangci(Iprorn pse) {
            return pse;
        }
    }

    public class PuraPhlaidu extends Iprorn {
        public Iprorn sangci(Iprorn pse) {
            return new PuraPhlaidu();
        }
    }

    public class Mopod extends Iprorn {
        public Iprorn sangci(Iprorn pse) {
            return this;
        }
    }

...and given the following setup code:

    Iprorn foo = new PuraPhlaidu();
    Mopod bar = new Mopod();

[1m[38;5;16m[48;5;206m            [0m
[1m[38;5;16m[48;5;206m   PART 1   [0m
[1m[38;5;16m[48;5;206m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.sangci(foo.sangci(bar))

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;213m[48;5;53m              [0m
[1m[38;5;213m[48;5;53m   SOLUTION   [0m
[1m[38;5;213m[48;5;53m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;155m            [0m
[1m[38;5;16m[48;5;155m   PART 2   [0m
[1m[38;5;16m[48;5;155m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;192m[48;5;22m              [0m
[1m[38;5;192m[48;5;22m   SOLUTION   [0m
[1m[38;5;192m[48;5;22m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────

Given the following type declarations:

    public interface Troedia {

        public Troedia euri(Troedia ap);
    }

    public class Sunteck implements Troedia {
        public Troedia euri(Troedia ap) {
            return this;
        }
    }

    public class Liochroc implements Troedia {
        public Troedia euri(Troedia ap) {
            return new Sunteck();
        }
    }

...and given the following setup code:

    Liochroc foo = new Liochroc();
    Troedia bar = new Sunteck();

[1m[38;5;16m[48;5;69m            [0m
[1m[38;5;16m[48;5;69m   PART 1   [0m
[1m[38;5;16m[48;5;69m            [0m

Draw an AST for the following expression, labeling the [1mstatic type[22m (a.k.a.
[1mcompile-time type[22m) of each node in the tree:

    foo.euri(foo.euri(bar))

(The static type of an expression is the type that the compiler uses to check
the code [3mbefore[23m it runs.)

[1m[38;5;111m[48;5;17m              [0m
[1m[38;5;111m[48;5;17m   SOLUTION   [0m
[1m[38;5;111m[48;5;17m              [0m

[3m<< See window titled “Part 1 Solution” >>[23m

┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄

[1m[38;5;16m[48;5;203m            [0m
[1m[38;5;16m[48;5;203m   PART 2   [0m
[1m[38;5;16m[48;5;203m            [0m

Draw an AST for the same expression, this time labeling the [1mruntime type[22m of each
node in the tree.

(The runtime type of an expression is the type of the actual value that appears
when the code runs.)

[1m[38;5;210m[48;5;52m              [0m
[1m[38;5;210m[48;5;52m   SOLUTION   [0m
[1m[38;5;210m[48;5;52m              [0m

[3m<< See window titled “Part 2 Solution” >>[23m

────────────────────────────────────────────────────────────────────────────────

[0m
